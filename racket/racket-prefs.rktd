(
 (readline-input-history
  (
   #"null"
   #"(empty? '())"
   #"(null? '())"
   #"(make-hash-eq)"
   #"(make-hash-eqv)"
   #"(letrec ([f (lambda (x) (if (h (g x)) (add1 x) (sub1 x)))]\n           [g (lambda (y) (let ([x 5]) (h 5) (if (zero? x) y (g (sub1 y)))))]\n           [h (lambda (z) #t)])\n    (f 5))"
   #"(letrec\n  )"
   #"letrec"
   #"(phase1-eval         (remove-unused-vars/rel\n            (generate-prog\n            (ir-rel ((~binders a))\n              (fresh ((~binders x y))\n                (== (#%lv-ref x) (#%lv-ref a)))))))"
   #"(require (for-syntax \"unit-test-infra.rkt\" \"private/compile/remove-unused-vars.rkt\"))"
   #"(require \"private/compile/remove-unused-vars.rkt\")"
   #"(phase1-eval (define prog (generate-prog (ir-rel ((~binders a))\n              (fresh ((~binders x y))\n                (== (#%lv-ref x) (#%lv-ref a))))))\n    (displayln prog)\n    (displayln (remove-unused-vars/rel prog)))"
   #"(require syntax/macro-testing)"
   #"(require \"private/syntax-classes.rkt\")"
   #"(require (for-syntax racket/base))"
   #"(require \"private/forms.rkt\")"
   #"(require \"unit-test-infra.rkt\")"
   #"(hash-ref x 5 #f)"
   #"(hash-ref x 5)"
   #"(define x (hash))"
   #"(empty? (cons 3 5))"
   #"(empty? 5)"
   #"(abstract)"
   #"(struct abstract ())"
   #"abstract"
   #"(run 1 (q) (pluso 5 3 q))"
   #"(require \"faster-miniKanren/numbers.rkt\")"
   #"(require minikanren)"
   #"pluso"
   #"(run 1  (r s q) (pluso r s q))"
   #"(run1  (r s q) (pluso r s q))"
   #"(run* (q) (pluso '() '(1 1) q))"
   #"(require \"../faster-miniKanren/numbers.rkt\")"
   #"(require \"~/faster-miniKanren/numbers.rkt\")"
   #"(set-subtract x-st bads)"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (and (not (equal? e1 e2)) (subset? e1 e2)))\n\n      e2))"
   #"(length bads"
   #"bads"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (and (not (equal? e1 e2)) (subset? e1 e2)))\n\n      e1))"
   #"(set-count bads)"
   #"(length bads)"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (subset? e1 e2))\n\n      e2))"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (subset? e1 e2))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n "
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (= (min (set-count e1) (set-count e2))\n                         (set-count (set-intersect e1 e2))))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n  "
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (= (min (set-count e1) (set-count e2))\n                         (set-count (set-intersect e1 e2)))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n  )"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st])"
   #"x-st"
   #"(set-count x-st)"
   #"(define x-st (list->set (map list->set x)))"
   #"(length x)"
   #"x"
   #"(define x (cons '(C1 A1 D2 A2) x))"
   #"(define x\n    (list\n      '(B1 C2)\n      '(D1 A2)\n      '(D1 A2 C1)\n      '(D1 B2 A2 D1)\n      '(D1 B2 A2 C1)\n      '(C1 D2 A2)\n      '(C1 D2 B2 A2)\n      '(C1 A1 D2 B2 A2)\n      '(C1 A1)\n      '(D2 B2 C2)\n      '(C2 A1 D2 B2)))"
   #"foobar hello world"
   #"(for ([c (current-input-port)])\n    (displayln \"1\"))"
   #"(equal? 'unsafe (syntax->datum #'unsafe))"
   #"(eq? 'unsafe (syntax->datum #'unsafe))"
   #"(symbol=? 'unsafe (syntax->datum #'unsafe))"
   #"(syntax->datum #'unsafe-make-place-local)"
   #"(~datum return)"
   #"(return 6)"
   #"(define-syntax return (make-rename-transformer #'k))"
   #"(define return (make-rename-transformer #'k))"
   #"(define k (lambda (_) 5))"
   #"#'(let () (define x 5))"
   #"(let () (define x 5))"
   #"(let () 5)"
   #"(let () 50\n  0\n  )"
   #"(for ([x (in-range 5 3)])\n    (displayln x))"
   #"(caddr e)"
   #"e"
   #"(define e (string-split s \" \"))"
   #"s"
   #"(define s \"3,444 -> 55,66\")"
   #"(let-values ([(x) (foo)]) x)"
   #"(define (foo) 5)"
   #"(exit)"
   #"(run* (q) (foo q))"
   #"(foo '(5 6))"
   #"(define (foo q) (fresh (a) (== q `(5 ,a))))"
   #"(and stuff)"
   #"(apply and stuff)"
   #"(define stuff '(#t #f #f #t))"
   #"(define x (define y 5))"
   #"(- 140737351438352 140737351847920)"
   #"'(a . b . c)"
   #"'(y . (w . (x . ())) . ())"
   #"'(y . (w . (x . ())))"
   #"'(y . (w . (x . ())) . (z . ()))"
   #"(check-true* set=?  \n    [(unique-bound-vars 'x) '()]\n    [(unique-bound-vars '(lambda (x) y)) '()]\n    [(unique-bound-vars '(lambda (x) (x y))) '(x)]\n    [(unique-bound-vars '((lambda (x) ((x y) e))\n                          (lambda (c) \n                            (x (lambda (x) (x (e c)))))))\n     '(x c)]\n    [(unique-bound-vars '(lambda (y) y)) '(y)]\n    [(unique-bound-vars '(lambda (x) (y z))) '()]\n    [(unique-bound-vars '(lambda (x) (lambda (x) x))) '(x)])"
   #"(define (unique-bound-vars expr)\n    (match expr\n      [_ #:when (symbol? expr) '()]\n      [`(lambda (,p) ,b) (if (var-occurs? p b) (list p) '())]\n      [`(,op ,rand) (union (unique-bound-vars op) (unique-bound-vars rand))]))"
   #"(chk\n    #:t (var-occurs-both? 'x '(lambda (x) (x (lambda (x) x))))\n    (values #f #t) \n    #:t (var-occurs-both? 'x '(x (lambda (x) x)))\n    (values #t #t)\n    #:t (var-occurs-both? 'x '(lambda (y) (x (lambda (x) x)))) \n    (values #t #t)\n    #:t (var-occurs-both? 'x '(lambda (x) (lambda (x) (x (lambda (x) x)))))\n    (values #f #t)\n    #:t (var-occurs-both? 'x '(lambda (x) (lambda (y) (lambda (x) (x (lambda (x) x))))))\n    (values #f #t)\n    #:t (var-occurs-both? 'x '(lambda (y) (lambda (x) (lambda (z) (lambda (x) (x (lambda (x) x)))))))\n    (values #f #t))"
   #"(define (var-occurs-both? id expr)\n    (match expr\n      [_ #:when (symbol? expr) (values (eqv? id expr) #f)]\n      [`(lambda (,p) ,b) (if (eqv? id p) (values #f (var-occurs-bound? id b)) (var-occurs-both? id b))]\n      [`(,op ,rand)\n       (let-values ([(free-in-op bound-in-op) (var-occurs-both? id op)]\n                    [(free-in-rand bound-in-rand) (var-occurs-both? id rand)])\n         (values (or free-in-op free-in-rand) (or bound-in-op bound-in-rand)))]))"
   #"(define (var-occurs-both? id expr)\n    (match expr\n      [_ #:when (symbol? expr) (values (eqv? id expr) #f)]\n      [`(lambda (,p) ,b) (if (eqv? id p) (values #f (var-occurs-bound? id b)))]\n      [`(,op ,rand)\n       (let-values ([(free-in-op bound-in-op) (var-occurs-both? id op)]\n                    [(free-in-rand bound-in-rand) (var-occurs-both? id rand)])\n         (values (or free-in-op free-in-rand) (or bound-in-op bound-in-rand)))]))"
   #"a-list"
   #"((c . #&15) (e . #&f) (b . #&15) (a . #&15))"
   #"(walk-symbol-update 'a a-list)"
   #"(define a-list `((c . ,(box 15)) (e . ,(box 'f)) (b . ,(box 'c)) (a . ,(box 'b))))"
   #"(define (walk-symbol-update x s)\n    (let ([a (assv x s)])\n      (cond\n        [a\n         (let ([res (walk-symbol-update (unbox (cdr a)) s)])\n           (set-box! (cdr a) res)\n           res)]\n        [else x])))"
   #"(check-true* equal? \n    [(lex '(lambda (x) x) '())\n     '(lambda (var 0))]\n    [(lex '(lambda (y) (lambda (x) y)) '())\n     '(lambda (lambda (var 1)))]\n    [(lex '(lambda (y) (lambda (x) (x y))) '())\n     '(lambda (lambda ((var 0) (var 1))))]\n    [(lex '(lambda (x) (lambda (x) (x x))) '())\n     '(lambda (lambda ((var 0) (var 0))))]\n    [(lex '(lambda (y) ((lambda (x) (x y)) (lambda (c) (lambda (d) (y c))))) '()) \n     '(lambda ((lambda ((var 0) (var 1))) (lambda (lambda ((var 2) (var 1))))))]\n    [(lex '(lambda (a)\n             (lambda (b)\n               (lambda (c)\n                 (lambda (a)\n                   (lambda (b)\n                     (lambda (d)\n                       (lambda (a)\n                         (lambda (e)\n                           (((((a b) c) d) e) a))))))))) '())\n     '(lambda\n        (lambda\n          (lambda\n            (lambda\n              (lambda\n                (lambda\n                  (lambda\n                    (lambda\n                      ((((((var 1) (var 3)) (var 5)) (var 2)) (var 0)) (var 1))))))))))]\n    [(lex '(lambda (a)\n             (lambda (b)\n               (lambda (c)\n                 (lambda (w)\n                   (lambda (x)\n                     (lambda (y)\n                       ((lambda (a)\n                          (lambda (b)\n                            (lambda (c)\n                              (((((a b) c) w) x) y))))\n                        (lambda (w)\n                          (lambda (x)\n                            (lambda (y)\n                              (((((a b) c) w) x) y))))))))))) '())\n     '(lambda \n        (lambda \n          (lambda \n            (lambda \n              (lambda \n                (lambda \n                  ((lambda\n                     (lambda\n                       (lambda\n                         ((((((var 2) (var 1)) (var 0)) (var 5)) (var 4)) (var 3)))))\n                   (lambda\n                     (lambda\n                       (lambda\n                         ((((((var 8) (var 7)) (var 6)) (var 2)) (var 1)) (var 0))))))))))))])"
  ))
)
