(
 (readline-input-history
  (
   #"(define x (phase1-eval (foobar 3 4)))"
   #"(struct foobar (a b))"
   #"(require syntax/macro-testing)"
   #"(phase1-eval (failure? (alpha=? 3 4)))"
   #"(phase1-eval (failure? res))"
   #"(failure? res)"
   #"(foobar:failure? res)"
   #"(require (prefix-in foobar: \"private/compile/test/unit-test-infra.rkt\"))"
   #"res"
   #"(define res (phase1-eval (alpha=? 3 4)))"
   #"(require (for-syntax \"private/compile/test/unit-test-infra.rkt\"))"
   #"res"
   #"(define res (phase1-eval (alpha=? 3 4)))"
   #"(require (for-syntax \"unit-test-infra.rkt\"))"
   #"(phase1-eval (values 3 4))"
   #"(require syntax/macro-testing)"
   #"(get-error-message (failure 1 2))"
   #"(get-error-message (success))"
   #"(success? (success))"
   #"(success? 1)"
   #"(require \"private/compile/test/unit-test-infra.rkt\")"
   #"(displayln x)"
   #"(syntax->datum x)"
   #"x"
   #"(define x #'hello)"
   #"syntax->datum"
   #"stx->datum"
   #"false?"
   #"t?"
   #"(boolean? #t)"
   #"(true? #t)"
   #"null"
   #"(empty? '())"
   #"(null? '())"
   #"(make-hash-eq)"
   #"(make-hash-eqv)"
   #"(letrec ([f (lambda (x) (if (h (g x)) (add1 x) (sub1 x)))]\n           [g (lambda (y) (let ([x 5]) (h 5) (if (zero? x) y (g (sub1 y)))))]\n           [h (lambda (z) #t)])\n    (f 5))"
   #"(letrec\n  )"
   #"letrec"
   #"(phase1-eval         (remove-unused-vars/rel\n            (generate-prog\n            (ir-rel ((~binders a))\n              (fresh ((~binders x y))\n                (== (#%lv-ref x) (#%lv-ref a)))))))"
   #"(require (for-syntax \"unit-test-infra.rkt\" \"private/compile/remove-unused-vars.rkt\"))"
   #"(require \"private/compile/remove-unused-vars.rkt\")"
   #"(phase1-eval (define prog (generate-prog (ir-rel ((~binders a))\n              (fresh ((~binders x y))\n                (== (#%lv-ref x) (#%lv-ref a))))))\n    (displayln prog)\n    (displayln (remove-unused-vars/rel prog)))"
   #"(require syntax/macro-testing)"
   #"(require \"private/syntax-classes.rkt\")"
   #"(require (for-syntax racket/base))"
   #"(require \"private/forms.rkt\")"
   #"(require \"unit-test-infra.rkt\")"
   #"(hash-ref x 5 #f)"
   #"(hash-ref x 5)"
   #"(define x (hash))"
   #"(empty? (cons 3 5))"
   #"(empty? 5)"
   #"(abstract)"
   #"(struct abstract ())"
   #"abstract"
   #"(run 1 (q) (pluso 5 3 q))"
   #"(require \"faster-miniKanren/numbers.rkt\")"
   #"(require minikanren)"
   #"pluso"
   #"(run 1  (r s q) (pluso r s q))"
   #"(run1  (r s q) (pluso r s q))"
   #"(run* (q) (pluso '() '(1 1) q))"
   #"(require \"../faster-miniKanren/numbers.rkt\")"
   #"(require \"~/faster-miniKanren/numbers.rkt\")"
   #"(set-subtract x-st bads)"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (and (not (equal? e1 e2)) (subset? e1 e2)))\n\n      e2))"
   #"(length bads"
   #"bads"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (and (not (equal? e1 e2)) (subset? e1 e2)))\n\n      e1))"
   #"(set-count bads)"
   #"(length bads)"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (subset? e1 e2))\n\n      e2))"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (subset? e1 e2))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n "
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (= (min (set-count e1) (set-count e2))\n                         (set-count (set-intersect e1 e2))))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n  "
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (= (min (set-count e1) (set-count e2))\n                         (set-count (set-intersect e1 e2)))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n  )"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st])"
   #"x-st"
   #"(set-count x-st)"
   #"(define x-st (list->set (map list->set x)))"
   #"(length x)"
  ))
)
