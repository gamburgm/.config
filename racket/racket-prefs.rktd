(
 (readline-input-history
  (
   #"(hash-ref x 5 #f)"
   #"(hash-ref x 5)"
   #"(define x (hash))"
   #"(empty? (cons 3 5))"
   #"(empty? 5)"
   #"(empty? '())"
   #"(abstract)"
   #"(struct abstract ())"
   #"abstract"
   #"(run 1 (q) (pluso 5 3 q))"
   #"(require \"faster-miniKanren/numbers.rkt\")"
   #"(require minikanren)"
   #"pluso"
   #"(run 1  (r s q) (pluso r s q))"
   #"(run1  (r s q) (pluso r s q))"
   #"(run* (q) (pluso '() '(1 1) q))"
   #"(require \"../faster-miniKanren/numbers.rkt\")"
   #"(require \"~/faster-miniKanren/numbers.rkt\")"
   #"(set-subtract x-st bads)"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (and (not (equal? e1 e2)) (subset? e1 e2)))\n\n      e2))"
   #"(length bads"
   #"bads"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (and (not (equal? e1 e2)) (subset? e1 e2)))\n\n      e1))"
   #"(set-count bads)"
   #"(length bads)"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (subset? e1 e2))\n\n      e2))"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (subset? e1 e2))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n "
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (= (min (set-count e1) (set-count e2))\n                         (set-count (set-intersect e1 e2))))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n  "
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st]\n               #:when (= (min (set-count e1) (set-count e2))\n                         (set-count (set-intersect e1 e2)))\n      (if (< (set-count e1) (set-count e2)) e1 e2)))\n  )"
   #"(define bads\n    (for*/set ([e1 x-st]\n               [e2 x-st])"
   #"x-st"
   #"(set-count x-st)"
   #"(define x-st (list->set (map list->set x)))"
   #"(length x)"
   #"x"
   #"(define x (cons '(C1 A1 D2 A2) x))"
   #"(define x\n    (list\n      '(B1 C2)\n      '(D1 A2)\n      '(D1 A2 C1)\n      '(D1 B2 A2 D1)\n      '(D1 B2 A2 C1)\n      '(C1 D2 A2)\n      '(C1 D2 B2 A2)\n      '(C1 A1 D2 B2 A2)\n      '(C1 A1)\n      '(D2 B2 C2)\n      '(C2 A1 D2 B2)))"
   #"foobar hello world"
   #"(for ([c (current-input-port)])\n    (displayln \"1\"))"
   #"(equal? 'unsafe (syntax->datum #'unsafe))"
   #"(eq? 'unsafe (syntax->datum #'unsafe))"
   #"(symbol=? 'unsafe (syntax->datum #'unsafe))"
   #"(syntax->datum #'unsafe-make-place-local)"
   #"(~datum return)"
   #"(return 6)"
   #"(define-syntax return (make-rename-transformer #'k))"
   #"(define return (make-rename-transformer #'k))"
   #"(define k (lambda (_) 5))"
   #"#'(let () (define x 5))"
   #"(let () (define x 5))"
   #"(let () 5)"
   #"(let () 50\n  0\n  )"
   #"(for ([x (in-range 5 3)])\n    (displayln x))"
   #"(caddr e)"
   #"e"
   #"(define e (string-split s \" \"))"
   #"s"
   #"(define s \"3,444 -> 55,66\")"
   #"(let-values ([(x) (foo)]) x)"
   #"(define (foo) 5)"
   #"(exit)"
   #"(run* (q) (foo q))"
   #"(foo '(5 6))"
   #"(define (foo q) (fresh (a) (== q `(5 ,a))))"
   #"(and stuff)"
   #"(apply and stuff)"
   #"(define stuff '(#t #f #f #t))"
   #"(define x (define y 5))"
   #"(- 140737351438352 140737351847920)"
   #"'(a . b . c)"
   #"'(y . (w . (x . ())) . ())"
   #"'(y . (w . (x . ())))"
   #"'(y . (w . (x . ())) . (z . ()))"
   #"(check-true* set=?  \n    [(unique-bound-vars 'x) '()]\n    [(unique-bound-vars '(lambda (x) y)) '()]\n    [(unique-bound-vars '(lambda (x) (x y))) '(x)]\n    [(unique-bound-vars '((lambda (x) ((x y) e))\n                          (lambda (c) \n                            (x (lambda (x) (x (e c)))))))\n     '(x c)]\n    [(unique-bound-vars '(lambda (y) y)) '(y)]\n    [(unique-bound-vars '(lambda (x) (y z))) '()]\n    [(unique-bound-vars '(lambda (x) (lambda (x) x))) '(x)])"
   #"(define (unique-bound-vars expr)\n    (match expr\n      [_ #:when (symbol? expr) '()]\n      [`(lambda (,p) ,b) (if (var-occurs? p b) (list p) '())]\n      [`(,op ,rand) (union (unique-bound-vars op) (unique-bound-vars rand))]))"
   #"(chk\n    #:t (var-occurs-both? 'x '(lambda (x) (x (lambda (x) x))))\n    (values #f #t) \n    #:t (var-occurs-both? 'x '(x (lambda (x) x)))\n    (values #t #t)\n    #:t (var-occurs-both? 'x '(lambda (y) (x (lambda (x) x)))) \n    (values #t #t)\n    #:t (var-occurs-both? 'x '(lambda (x) (lambda (x) (x (lambda (x) x)))))\n    (values #f #t)\n    #:t (var-occurs-both? 'x '(lambda (x) (lambda (y) (lambda (x) (x (lambda (x) x))))))\n    (values #f #t)\n    #:t (var-occurs-both? 'x '(lambda (y) (lambda (x) (lambda (z) (lambda (x) (x (lambda (x) x)))))))\n    (values #f #t))"
   #"(define (var-occurs-both? id expr)\n    (match expr\n      [_ #:when (symbol? expr) (values (eqv? id expr) #f)]\n      [`(lambda (,p) ,b) (if (eqv? id p) (values #f (var-occurs-bound? id b)) (var-occurs-both? id b))]\n      [`(,op ,rand)\n       (let-values ([(free-in-op bound-in-op) (var-occurs-both? id op)]\n                    [(free-in-rand bound-in-rand) (var-occurs-both? id rand)])\n         (values (or free-in-op free-in-rand) (or bound-in-op bound-in-rand)))]))"
   #"(define (var-occurs-both? id expr)\n    (match expr\n      [_ #:when (symbol? expr) (values (eqv? id expr) #f)]\n      [`(lambda (,p) ,b) (if (eqv? id p) (values #f (var-occurs-bound? id b)))]\n      [`(,op ,rand)\n       (let-values ([(free-in-op bound-in-op) (var-occurs-both? id op)]\n                    [(free-in-rand bound-in-rand) (var-occurs-both? id rand)])\n         (values (or free-in-op free-in-rand) (or bound-in-op bound-in-rand)))]))"
   #"a-list"
   #"((c . #&15) (e . #&f) (b . #&15) (a . #&15))"
   #"(walk-symbol-update 'a a-list)"
   #"(define a-list `((c . ,(box 15)) (e . ,(box 'f)) (b . ,(box 'c)) (a . ,(box 'b))))"
   #"(define (walk-symbol-update x s)\n    (let ([a (assv x s)])\n      (cond\n        [a\n         (let ([res (walk-symbol-update (unbox (cdr a)) s)])\n           (set-box! (cdr a) res)\n           res)]\n        [else x])))"
   #"(check-true* equal? \n    [(lex '(lambda (x) x) '())\n     '(lambda (var 0))]\n    [(lex '(lambda (y) (lambda (x) y)) '())\n     '(lambda (lambda (var 1)))]\n    [(lex '(lambda (y) (lambda (x) (x y))) '())\n     '(lambda (lambda ((var 0) (var 1))))]\n    [(lex '(lambda (x) (lambda (x) (x x))) '())\n     '(lambda (lambda ((var 0) (var 0))))]\n    [(lex '(lambda (y) ((lambda (x) (x y)) (lambda (c) (lambda (d) (y c))))) '()) \n     '(lambda ((lambda ((var 0) (var 1))) (lambda (lambda ((var 2) (var 1))))))]\n    [(lex '(lambda (a)\n             (lambda (b)\n               (lambda (c)\n                 (lambda (a)\n                   (lambda (b)\n                     (lambda (d)\n                       (lambda (a)\n                         (lambda (e)\n                           (((((a b) c) d) e) a))))))))) '())\n     '(lambda\n        (lambda\n          (lambda\n            (lambda\n              (lambda\n                (lambda\n                  (lambda\n                    (lambda\n                      ((((((var 1) (var 3)) (var 5)) (var 2)) (var 0)) (var 1))))))))))]\n    [(lex '(lambda (a)\n             (lambda (b)\n               (lambda (c)\n                 (lambda (w)\n                   (lambda (x)\n                     (lambda (y)\n                       ((lambda (a)\n                          (lambda (b)\n                            (lambda (c)\n                              (((((a b) c) w) x) y))))\n                        (lambda (w)\n                          (lambda (x)\n                            (lambda (y)\n                              (((((a b) c) w) x) y))))))))))) '())\n     '(lambda \n        (lambda \n          (lambda \n            (lambda \n              (lambda \n                (lambda \n                  ((lambda\n                     (lambda\n                       (lambda\n                         ((((((var 2) (var 1)) (var 0)) (var 5)) (var 4)) (var 3)))))\n                   (lambda\n                     (lambda\n                       (lambda\n                         ((((((var 8) (var 7)) (var 6)) (var 2)) (var 1)) (var 0))))))))))))])"
   #"(define (lex expr acc)\n    (match expr\n      [_ #:when (symbol? expr) `(var ,(list-index-ofv expr acc))]\n      [`(lambda (,p) ,b) `(lambda ,(lex b (cons p acc)))]\n      [`(,op ,rand) `(,(lex op acc) ,(lex rand acc))]))"
   #"(lex '(lambda (y) (lambda (x) (x y))) '())"
   #"(lex '(lambda (y) (lambda (x) y)) '())"
   #"(lex `(lambda (x) x) '())"
   #"(define (list-index-ofv sym ls)\n    (cond\n      [(empty? ls) (error \"fuck\")]\n      [(cons? ls)\n       (if (eqv? (car ls) sym)\n         0\n         (+ 1 (list-index-ofv sym (cdr ls))))]))"
   #"(define (lex expr acc)\n    (match expr\n      [_ #:when (symbol? expr) `(var ,(list-index-ofv expr acc))]\n      [`(lambda (,p) ,b) `(lambda ,(lex b (cons p acc)))]\n      [`(,op ,rand) `(,(lex op acc) (lex rand acc))]))"
   #"(check-true* set=?\n    [(unique-free-vars 'x) '(x)]\n    [(unique-free-vars '(lambda (x) (x y))) '(y)]\n    [(unique-free-vars '((lambda (x) ((x y) e)) (lambda (c) (x (lambda (x) (x (e c))))))) '(y e x)])"
   #"(unique-free-vars '((lambda (x) ((x y) e)) (lambda (c) (x (lambda (x) (x (e c)))))))"
   #"(check-true* equal? \n    [(unique-free-vars 'x) '(x)]\n    [(unique-free-vars '(lambda (x) (x y))) '(y)]\n    [(unique-free-vars '((lambda (x) ((x y) e)) (lambda (c) (x (lambda (x) (x (e c))))))) '(y e x)])"
   #"(define (unique-free-vars expr)\n    (match expr\n      [_ #:when (symbol? expr) (list expr)]\n      [`(lambda (,p) ,b) (remv p (unique-free-vars b))]\n      [`(,op ,rand) (union (unique-free-vars op) (unique-free-vars rand))]))"
   #"(check-true* equal? \n    [(var-occurs-bound? 'x 'x) '#f]\n    [(var-occurs-bound? 'x '(lambda (x) x)) '#t]\n    [(var-occurs-bound? 'y '(lambda (x) x)) '#f]\n    [(var-occurs-bound? 'x '((lambda (x) (x x)) (x x))) '#t]\n    [(var-occurs-bound? 'z '(lambda (y) (lambda (x) (y z)))) '#f]\n    [(var-occurs-bound? 'z '(lambda (y) (lambda (z) (y z)))) '#t]\n    [(var-occurs-bound? 'x '(lambda (x) y)) '#f]\n    [(var-occurs-bound? 'x '(lambda (x) (lambda (x) x))) '#t])"
   #"(\n  )"
   #"(define (var-occurs-bound? id expr)\n    (match expr\n      [_ #:when (symbol? expr) #f]\n      [`(lambda (,p) ,b) (if (eqv? id p) (var-occurs? id b) (var-occurs-bound? id b))]\n      [`(,op ,rand) (or (var-occurs-bound? id op) (var-occurs-bound? id rand))]))"
   #"(var-occurs-bound? 'z '(lambda (z) (y z)))"
   #"(var-occurs-bound? `(lambda (y) z))"
   #"(var-occurs-bound? 'z `(lambda (y) y))"
  ))
)
